<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Family Period Tracker</title>
    <style>
        /* Basic reset and font setup */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #667eea;
            margin-bottom: 30px;
            text-align: center;
        }

        /* Profile selection dropdown */
        .profile-section {
            margin-bottom: 30px;
        }

        .profile-section label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
        }

        select, input, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
        }

        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Button styles */
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
            margin-top: 10px;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button.secondary {
            background: #95a5a6;
        }

        button.secondary:hover {
            background: #7f8c8d;
        }

        button.danger {
            background: #e74c3c;
        }

        button.danger:hover {
            background: #c0392b;
        }

        /* Calendar grid */
        .calendar {
            margin: 30px 0;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .calendar-header h2 {
            color: #333;
            font-size: 20px;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            padding: 5px;
        }

        .calendar-day:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .calendar-day.day-header {
            font-weight: 600;
            color: #667eea;
            cursor: default;
            border: none;
        }

        .calendar-day.day-header:hover {
            transform: none;
        }

        .calendar-day.other-month {
            color: #ccc;
        }

        .calendar-day.period {
            background: #ff6b9d;
            color: white;
            border-color: #ff6b9d;
        }

        .calendar-day.predicted {
            background: #ffd4e5;
            border-color: #ff6b9d;
        }

        /* Entry form */
        .entry-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-top: 30px;
        }

        .entry-form h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        /* Stats section */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 30px 0;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }

        .stat-card h4 {
            color: #667eea;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .stat-card p {
            font-size: 24px;
            font-weight: 600;
            color: #333;
        }

        /* History section */
        .history {
            margin-top: 30px;
        }

        .history h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .history-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-item-content {
            flex: 1;
        }

        .history-item-date {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 5px;
        }

        .history-item-notes {
            color: #666;
            font-size: 14px;
        }

        /* Hidden class */
        .hidden {
            display: none;
        }

        /* Responsive design for mobile */
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            .calendar-grid {
                gap: 4px;
            }

            .calendar-day {
                font-size: 14px;
            }

            button {
                padding: 10px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üë®‚Äçüë©‚Äçüëß‚Äçüëß Family Period Tracker</h1>

        <!-- Profile Selection -->
        <div class="profile-section">
            <label for="profileSelect">Select Profile:</label>
            <select id="profileSelect">
                <!-- Profiles will be populated by JavaScript -->
            </select>
            <button onclick="showAddProfileForm()">Add New Profile</button>
            <button class="secondary" onclick="manageProfiles()">Manage Profiles</button>
        </div>

        <!-- Add Profile Form (hidden by default) -->
        <div id="addProfileForm" class="entry-form hidden">
            <h3>Add New Profile</h3>
            <div class="form-group">
                <label for="newProfileName">Name:</label>
                <input type="text" id="newProfileName" placeholder="Enter name">
            </div>
            <div class="form-group">
                <label for="avgCycleLength">Average Cycle Length (days):</label>
                <input type="number" id="avgCycleLength" value="28" min="20" max="45">
            </div>
            <div class="form-group">
                <label for="avgPeriodLength">Average Period Length (days):</label>
                <input type="number" id="avgPeriodLength" value="5" min="2" max="10">
            </div>
            <button onclick="addProfile()">Save Profile</button>
            <button class="secondary" onclick="cancelAddProfile()">Cancel</button>
        </div>

        <!-- Stats Display -->
        <div class="stats">
            <div class="stat-card">
                <h4>Average Cycle</h4>
                <p id="avgCycle">--</p>
            </div>
            <div class="stat-card">
                <h4>Last Period</h4>
                <p id="lastPeriod">--</p>
            </div>
            <div class="stat-card">
                <h4>Next Expected</h4>
                <p id="nextExpected">--</p>
            </div>
        </div>

        <!-- Calendar -->
        <div class="calendar">
            <div class="calendar-header">
                <h2 id="currentMonth">Month Year</h2>
                <div class="calendar-nav">
                    <button onclick="previousMonth()">‚Üê Prev</button>
                    <button onclick="today()">Today</button>
                    <button onclick="nextMonth()">Next ‚Üí</button>
                </div>
            </div>
            <div class="calendar-grid" id="calendarGrid">
                <!-- Calendar will be populated by JavaScript -->
            </div>
        </div>

        <!-- Entry Form -->
        <div id="entryForm" class="entry-form hidden">
            <h3>Log Entry for <span id="selectedDate"></span></h3>
            <div class="form-group">
                <label>
                    <input type="checkbox" id="isPeriodDay"> Period Day
                </label>
            </div>
            <div class="form-group">
                <label for="symptoms">Symptoms:</label>
                <input type="text" id="symptoms" placeholder="e.g., cramps, headache">
            </div>
            <div class="form-group">
                <label for="mood">Mood:</label>
                <input type="text" id="mood" placeholder="e.g., happy, irritable">
            </div>
            <div class="form-group">
                <label for="notes">Notes:</label>
                <textarea id="notes" rows="3" placeholder="Any additional notes..."></textarea>
            </div>
            <button onclick="saveEntry()">Save Entry</button>
            <button class="danger" onclick="deleteEntry()">Delete Entry</button>
            <button class="secondary" onclick="closeEntryForm()">Cancel</button>
        </div>

        <!-- History -->
        <div class="history">
            <h3>Recent Entries</h3>
            <div id="historyList">
                <!-- History items will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        // Data structure to hold all information
        let appData = {
            profiles: [],
            currentProfileId: null,
            currentMonth: new Date().getMonth(),
            currentYear: new Date().getFullYear(),
            selectedDate: null
        };

        // Initialize the app when page loads
        function init() {
            loadData();
            
            // If no profiles exist, create a default one
            if (appData.profiles.length === 0) {
                appData.profiles.push({
                    id: generateId(),
                    name: "Profile 1",
                    avgCycleLength: 28,
                    avgPeriodLength: 5,
                    entries: []
                });
                appData.currentProfileId = appData.profiles[0].id;
                saveData();
            }
            
            // Set current profile to first profile if none selected
            if (!appData.currentProfileId && appData.profiles.length > 0) {
                appData.currentProfileId = appData.profiles[0].id;
            }
            
            populateProfileSelect();
            renderCalendar();
            updateStats();
            renderHistory();
        }

        // Generate unique ID for profiles and entries
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        // Save data to browser's local storage
        function saveData() {
            localStorage.setItem('periodTrackerData', JSON.stringify(appData));
        }

        // Load data from browser's local storage
        function loadData() {
            const saved = localStorage.getItem('periodTrackerData');
            if (saved) {
                appData = JSON.parse(saved);
            }
        }

        // Get the currently selected profile
        function getCurrentProfile() {
            return appData.profiles.find(p => p.id === appData.currentProfileId);
        }

        // Populate the profile dropdown
        function populateProfileSelect() {
            const select = document.getElementById('profileSelect');
            select.innerHTML = '';
            
            appData.profiles.forEach(profile => {
                const option = document.createElement('option');
                option.value = profile.id;
                option.textContent = profile.name;
                select.appendChild(option);
            });
            
            select.value = appData.currentProfileId;
            select.onchange = function() {
                appData.currentProfileId = this.value;
                saveData();
                renderCalendar();
                updateStats();
                renderHistory();
            };
        }

        // Show the add profile form
        function showAddProfileForm() {
            document.getElementById('addProfileForm').classList.remove('hidden');
        }

        // Cancel adding a profile
        function cancelAddProfile() {
            document.getElementById('addProfileForm').classList.add('hidden');
            document.getElementById('newProfileName').value = '';
        }

        // Add a new profile
        function addProfile() {
            const name = document.getElementById('newProfileName').value.trim();
            const cycleLength = parseInt(document.getElementById('avgCycleLength').value);
            const periodLength = parseInt(document.getElementById('avgPeriodLength').value);
            
            if (!name) {
                alert('Please enter a name');
                return;
            }
            
            const newProfile = {
                id: generateId(),
                name: name,
                avgCycleLength: cycleLength,
                avgPeriodLength: periodLength,
                entries: []
            };
            
            appData.profiles.push(newProfile);
            appData.currentProfileId = newProfile.id;
            saveData();
            
            cancelAddProfile();
            populateProfileSelect();
            renderCalendar();
            updateStats();
            renderHistory();
        }

        // Manage profiles (delete)
        function manageProfiles() {
            if (appData.profiles.length === 1) {
                alert('You must have at least one profile.');
                return;
            }
            
            const profile = getCurrentProfile();
            if (confirm(`Delete profile "${profile.name}"? This cannot be undone.`)) {
                appData.profiles = appData.profiles.filter(p => p.id !== profile.id);
                appData.currentProfileId = appData.profiles[0].id;
                saveData();
                populateProfileSelect();
                renderCalendar();
                updateStats();
                renderHistory();
            }
        }

        // Render the calendar for the current month
        function renderCalendar() {
            const grid = document.getElementById('calendarGrid');
            grid.innerHTML = '';
            
            // Update month/year display
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                              'July', 'August', 'September', 'October', 'November', 'December'];
            document.getElementById('currentMonth').textContent = 
                `${monthNames[appData.currentMonth]} ${appData.currentYear}`;
            
            // Add day headers (Sun, Mon, Tue, etc.)
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.className = 'calendar-day day-header';
                header.textContent = day;
                grid.appendChild(header);
            });
            
            // Get first day of month and total days
            const firstDay = new Date(appData.currentYear, appData.currentMonth, 1).getDay();
            const daysInMonth = new Date(appData.currentYear, appData.currentMonth + 1, 0).getDate();
            const daysInPrevMonth = new Date(appData.currentYear, appData.currentMonth, 0).getDate();
            
            const profile = getCurrentProfile();
            const entries = profile ? profile.entries : [];
            
            // Get predicted period dates
            const predictedDates = calculatePredictedDates();
            
            // Add empty cells for days before month starts
            for (let i = firstDay - 1; i >= 0; i--) {
                const day = document.createElement('div');
                day.className = 'calendar-day other-month';
                day.textContent = daysInPrevMonth - i;
                grid.appendChild(day);
            }
            
            // Add days of the month
            for (let i = 1; i <= daysInMonth; i++) {
                const day = document.createElement('div');
                day.className = 'calendar-day';
                day.textContent = i;
                
                const dateStr = `${appData.currentYear}-${String(appData.currentMonth + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                const entry = entries.find(e => e.date === dateStr);
                
                // Mark period days
                if (entry && entry.isPeriod) {
                    day.classList.add('period');
                }
                // Mark predicted period days
                else if (predictedDates.includes(dateStr)) {
                    day.classList.add('predicted');
                }
                
                // Add click handler
                day.onclick = () => openEntryForm(dateStr);
                
                grid.appendChild(day);
            }
            
            // Fill remaining cells
            const totalCells = grid.children.length - 7; // Subtract day headers
            const remainingCells = 35 - totalCells; // 5 weeks * 7 days = 35
            for (let i = 1; i <= remainingCells; i++) {
                const day = document.createElement('div');
                day.className = 'calendar-day other-month';
                day.textContent = i;
                grid.appendChild(day);
            }
        }

        // Calculate predicted period dates based on last period
        function calculatePredictedDates() {
            const profile = getCurrentProfile();
            if (!profile) return [];
            
            const periodEntries = profile.entries
                .filter(e => e.isPeriod)
                .sort((a, b) => new Date(b.date) - new Date(a.date));
            
            if (periodEntries.length === 0) return [];
            
            // Find the start of the last period (first day of consecutive period days)
            let lastPeriodStart = null;
            for (let i = 0; i < periodEntries.length; i++) {
                const currentDate = new Date(periodEntries[i].date);
                const nextDate = i < periodEntries.length - 1 ? new Date(periodEntries[i + 1].date) : null;
                
                if (!nextDate || (currentDate - nextDate) / (1000 * 60 * 60 * 24) > 1) {
                    lastPeriodStart = currentDate;
                    break;
                }
            }
            
            if (!lastPeriodStart) return [];
            
            // Calculate next expected period
            const nextPeriodStart = new Date(lastPeriodStart);
            nextPeriodStart.setDate(nextPeriodStart.getDate() + profile.avgCycleLength);
            
            // Generate predicted dates
            const predicted = [];
            for (let i = 0; i < profile.avgPeriodLength; i++) {
                const date = new Date(nextPeriodStart);
                date.setDate(date.getDate() + i);
                const dateStr = date.toISOString().split('T')[0];
                predicted.push(dateStr);
            }
            
            return predicted;
        }

        // Navigate to previous month
        function previousMonth() {
            appData.currentMonth--;
            if (appData.currentMonth < 0) {
                appData.currentMonth = 11;
                appData.currentYear--;
            }
            renderCalendar();
        }

        // Navigate to next month
        function nextMonth() {
            appData.currentMonth++;
            if (appData.currentMonth > 11) {
                appData.currentMonth = 0;
                appData.currentYear++;
            }
            renderCalendar();
        }

        // Go to current month
        function today() {
            const now = new Date();
            appData.currentMonth = now.getMonth();
            appData.currentYear = now.getFullYear();
            renderCalendar();
        }

        // Open the entry form for a specific date
        function openEntryForm(dateStr) {
            appData.selectedDate = dateStr;
            const profile = getCurrentProfile();
            const entry = profile.entries.find(e => e.date === dateStr);
            
            // Format date for display
            const date = new Date(dateStr + 'T00:00:00');
            document.getElementById('selectedDate').textContent = date.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            // Populate form with existing data if entry exists
            if (entry) {
                document.getElementById('isPeriodDay').checked = entry.isPeriod || false;
                document.getElementById('symptoms').value = entry.symptoms || '';
                document.getElementById('mood').value = entry.mood || '';
                document.getElementById('notes').value = entry.notes || '';
            } else {
                // Clear form for new entry
                document.getElementById('isPeriodDay').checked = false;
                document.getElementById('symptoms').value = '';
                document.getElementById('mood').value = '';
                document.getElementById('notes').value = '';
            }
            
            document.getElementById('entryForm').classList.remove('hidden');
        }

        // Close the entry form
        function closeEntryForm() {
            document.getElementById('entryForm').classList.add('hidden');
            appData.selectedDate = null;
        }

        // Save an entry
        function saveEntry() {
            const profile = getCurrentProfile();
            const dateStr = appData.selectedDate;
            
            const entry = {
                date: dateStr,
                isPeriod: document.getElementById('isPeriodDay').checked,
                symptoms: document.getElementById('symptoms').value.trim(),
                mood: document.getElementById('mood').value.trim(),
                notes: document.getElementById('notes').value.trim()
            };
            
            // Remove existing entry for this date if it exists
            profile.entries = profile.entries.filter(e => e.date !== dateStr);
            
            // Add new entry
            profile.entries.push(entry);
            
            saveData();
            closeEntryForm();
            renderCalendar();
            updateStats();
            renderHistory();
        }

        // Delete an entry
        function deleteEntry() {
            if (!confirm('Delete this entry?')) return;
            
            const profile = getCurrentProfile();
            profile.entries = profile.entries.filter(e => e.date !== appData.selectedDate);
            
            saveData();
            closeEntryForm();
            renderCalendar();
            updateStats();
            renderHistory();
        }

        // Update statistics display
        function updateStats() {
            const profile = getCurrentProfile();
            if (!profile) return;
            
            const periodEntries = profile.entries
                .filter(e => e.isPeriod)
                .sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Calculate average cycle length from actual data
            let avgCycle = profile.avgCycleLength;
            if (periodEntries.length >= 2) {
                // Find period start dates
                const starts = [];
                for (let i = 0; i < periodEntries.length; i++) {
                    const currentDate = new Date(periodEntries[i].date);
                    const nextDate = i < periodEntries.length - 1 ? new Date(periodEntries[i + 1].date) : null;
                    
                    if (!nextDate || (currentDate - nextDate) / (1000 * 60 * 60 * 24) > 1) {
                        starts.push(currentDate);
                    }
                }
                
                // Calculate average between starts
                if (starts.length >= 2) {
                    let total = 0;
                    for (let i = 0; i < starts.length - 1; i++) {
                        const days = (starts[i] - starts[i + 1]) / (1000 * 60 * 60 * 24);
                        total += days;
                    }
                    avgCycle = Math.round(total / (starts.length - 1));
                }
            }
            
            document.getElementById('avgCycle').textContent = avgCycle + ' days';
            
            // Last period date
            if (periodEntries.length > 0) {
                const lastDate = new Date(periodEntries[0].date);
                const daysAgo = Math.floor((new Date() - lastDate) / (1000 * 60 * 60 * 24));
                document.getElementById('lastPeriod').textContent = daysAgo + ' days ago';
            } else {
                document.getElementById('lastPeriod').textContent = 'No data';
            }
            
            // Next expected period
            const predicted = calculatePredictedDates();
            if (predicted.length > 0) {
                const nextDate = new Date(predicted[0]);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const daysUntil = Math.floor((nextDate - today) / (1000 * 60 * 60 * 24));
                
                if (daysUntil < 0) {
                    document.getElementById('nextExpected').textContent = 'Overdue';
                } else if (daysUntil === 0) {
                    document.getElementById('nextExpected').textContent = 'Today';
                } else {
                    document.getElementById('nextExpected').textContent = 'In ' + daysUntil + ' days';
                }
            } else {
                document.getElementById('nextExpected').textContent = 'No data';
            }
        }

        // Render recent history
        function renderHistory() {
            const profile = getCurrentProfile();
            const historyList = document.getElementById('historyList');
            historyList.innerHTML = '';
            
            if (!profile || profile.entries.length === 0) {
                historyList.innerHTML = '<p style="color: #999; text-align: center;">No entries yet</p>';
                return;
            }
            
            // Get last 10 entries with content
            const recentEntries = profile.entries
                .filter(e => e.symptoms || e.mood || e.notes || e.isPeriod)
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 10);
            
            recentEntries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'history-item';
                
                const date = new Date(entry.date + 'T00:00:00');
                const dateStr = date.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
                
                let content = '';
                if (entry.isPeriod) content += 'üî¥ Period day';
                if (entry.symptoms) content += (content ? ' ‚Ä¢ ' : '') + entry.symptoms;
                if (entry.mood) content += (content ? ' ‚Ä¢ ' : '') + entry.mood;
                if (entry.notes) content += (content ? ' ‚Ä¢ ' : '') + entry.notes;
                
                item.innerHTML = `
                    <div class="history-item-content">
                        <div class="history-item-date">${dateStr}</div>
                        <div class="history-item-notes">${content}</div>
                    </div>
                `;
                
                item.onclick = () => openEntryForm(entry.date);
                
                historyList.appendChild(item);
            });
        }

        // Start the app
        init();
    </script>
</body>
</html>